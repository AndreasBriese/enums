package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"text/template"
)

var tmpl = `// file generated by 'enums'
// do not alter

{{.Pack}}

type {{.Type}} {{.TypeType}}

const (
{{range $i, $v := .Vals}}{{$v}}
{{end}}
)

var {{.Type}}_Constants = [{{len .Names}}]{{.Type}} { 
	{{range $i, $v := .Names}}{{$v}},
	{{end}} 
}

func (t {{.Type}}) String() string{
	switch t {
	{{range $i, $v := .Wrds}}case {{$v}}: return "{{$v}}" 
	{{end}} 
	}
	return ""
}
`

type TpVal struct {
	Pack     string
	Type     string
	TypeType string
	Names    []string
	Vals     []string
	Wrds     []string
}

var (
	rgxPack, _  = regexp.Compile(`(?m)^package \S+`)
	rgxBlock, _ = regexp.Compile(`(?ms) \[@enums(.*?) @\]$`)
	rgxType, _  = regexp.Compile(`(?-m)\/\/ type (.*?) (.*?)\s`)
	rgxVal, _   = regexp.Compile(`(?-m)\-.+`)
	rgxWrd, _   = regexp.Compile(`^\S+`)

	postfix = "%v_enums.go"
	tmpFile = "enums_tmp.go"

	rgxErrLoc, _ = regexp.Compile(`(?-m)\:(\d+)\: duplicate case`)
)

func main() {

	if len(os.Args) == 0 {
		os.Exit(11)
	}

	gofle, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		os.Exit(10)
	}

	typesAndVals := new(TpVal)
	typesAndVals.Pack = rgxPack.FindString(string(gofle))

	indices := rgxBlock.FindAllStringIndex(string(gofle), -1)

	for _, idcs := range indices {

		t := template.Must(template.New("gen").Parse(tmpl))

		fle, err := os.Create(tmpFile)
		if err != nil {
			os.Exit(5)
		}
		defer fle.Close()

		thisTypeEnc := string(gofle)[idcs[0]:idcs[1]]
		parse(thisTypeEnc, typesAndVals)

		t.Execute(fle, typesAndVals)
		fle.Close()
		enumsFle := fmt.Sprintf(postfix, typesAndVals.Type)

		fle, err = os.Create(enumsFle)
		if err != nil {
			os.Exit(5)
		}
		defer fle.Close()
		gofmt := exec.Command("gofmt", tmpFile)
		gofmt.Stdout = fle
		if err := gofmt.Run(); err != nil {
			fmt.Println(err)
			os.Exit(8)
		}
		fle.Close()

		done := false
		for i, maxRepeats := 0, len(typesAndVals.Wrds)-1; i < maxRepeats; i++ {

			var errBuf bytes.Buffer
			gobuild := exec.Command("go", "build", enumsFle)
			gobuild.Stdout = os.Stdout
			gobuild.Stderr = &errBuf
			err := gobuild.Run()

			if err != nil {
				errMessg := string(errBuf.Bytes())
				// fmt.Println(err, errMessg)
				if rgxErrLoc.FindString(errMessg) != "" {
					commentOut(enumsFle, rgxErrLoc.FindAllStringSubmatch(errMessg, 1)[0][1])
					continue
				}
			}

			done = true
			break
		}

		if !done {
			fmt.Println("Sorry, enums can not produce buildable go enum file!")
			os.Exit(99)
		}

		err = os.Remove(tmpFile)
		if err != nil {
			os.Exit(9)
		}

		fmt.Printf("generated enum type '%v' in %v\n", typesAndVals.Type, enumsFle)

	}

}

func commentOut(fleName string, ln string) {
	lineNo, _ := strconv.Atoi(ln)

	err := os.Rename(fleName, tmpFile)
	if err != nil {
		os.Exit(11)
	}

	fle, err := os.Create(fleName)
	if err != nil {
		os.Exit(22)
	}
	defer fle.Close()

	errfle, err := os.Open(tmpFile)
	if err != nil {
		os.Exit(33)
	}
	defer errfle.Close()

	lncnt := 1
	scanner := bufio.NewScanner(errfle)
	for scanner.Scan() {
		line := scanner.Text()
		if lncnt == lineNo || lncnt == lineNo+1 {
			line = "//" + line
		}
		fle.Write([]byte(line + "\n"))
		lncnt++
	}

}

func parse(t2p string, tpval *TpVal) {

	block := rgxBlock.FindString(t2p)
	tpe := rgxType.FindAllStringSubmatch(block, -1)
	tpval.Type = tpe[0][1]
	tpval.TypeType = tpe[0][2]

	vals := rgxVal.FindAllString(block, -1)
	tpval.Vals = make([]string, len(vals))
	tpval.Names = make([]string, len(vals))
	tpval.Wrds = make([]string, 0, len(vals))
	for i, v := range vals {
		v = v[1:]
		tpval.Vals[i] = v
		vals[i] = rgxWrd.FindString(v)
		tpval.Names[i] = vals[i]
		tpval.Wrds = append(tpval.Wrds, vals[i])
	}
}
